---
layout: counter-app-tutorial
guide: 1
total_guides: 1
---
# Tutorial: Counter Application

## 2 The Set Up

### Define Our Module

Naturally we need a module so lets sort that out first.

{% highlight cl %}
(defmodule counter
  (export (new 0)
          (incr 1)
          (count 1)
          (counter 0)))
{% endhighlight %}

### Define Our Functions

Now we can start to define the functionality that will make up our module. Lets start with ``new``.. Keeping to Erlang and LFE design principles we want to keep our counters in their own processes, so when this is called just spin up a new counter and hand back the ``pid`` to the caller.

{% highlight cl %}
(defun new ()
  "For creating a new counter."
  (spawn 'counter 'counter '()))
{% endhighlight %}

Now of course having the ``pid`` to a process that does nothing but spawn itself isn't terribly useful so how about we implement the ``incr`` function to bump our counter up by 1.

{% highlight cl %}
(defun incr (counter)
  "Increments our counter value."
  (! counter (tuple 'incr)))
{% endhighlight %}

Notice that for the increment function we simply forward our request for an increment to occur and then end the function. Since our counter is designed to be a background process that will manage the counter it is holding and report back when asked. The increment step is an asynchronous action.

### Tracking Counter State

Having a running process that we can send an increment instruction to is all well and good, but in this case it's a bit useless if we can't ask for the current value of the counter. Or the value of the counter at the time it was requested, if you want to be picky, so lets implement our ``count`` function to request the current value of the count.

{% highlight cl %}
(defun count (counter)
  "Retrieves the value of the given counter."
  (! counter (tuple 'count (self)))
  (receive
    ((tuple 'count count)
     count)))
{% endhighlight %}

This function takes care of the steps required to talk to our running counter process and the provide a message back to the caller. First we send a message to the given counter process, asking for it's current count value, and then we wait for a response before responding with the result.

## 3 Thinking About Counting

### Define the Counter Process

Now that we have our communication methods in place we should set about defining the operations of counter process. This is the actual running loop that will manage the counter variable and respond to requests. Because we've already defined how we need to interact with this process, the construction is quite straight forward:

First we'll build our ``counter`` function to be our start the process from ``0``.

{% highlight cl %}
(defun counter ()
  "Runs our actual counter loop."
  (counter-loop 0))
{% endhighlight %}

No real surprises there, start our loop with our initial counter variable.

Now for our ``counter-loop`` function!

{% highlight cl %}
(defun counter-loop (count)
  (receive
    ((tuple incr)
     (counter-loop (+ count 1)))
    ((tuple 'count requestor)
     (! requestor (tuple 'count count))
     (counter-loop count))))
{% endhighlight %}

Pretty simple. Our initial value is passed in and the process waits to receive a message telling it to either increment the counter or return the current value.

### Testing It Out

Lets take it out for a spin:

{% highlight cl %}
> (c '"counter.lfe")
#(module counter)
> (set foo (: counter new))
<0.35.0>
> (: counter count foo)
0
> (: counter incr foo)
#(incr)
> (: counter incr foo)
#(incr)
> (: counter count foo)
2
{% endhighlight %}

Success! We create a new counter process and store the ``pid`` in ``foo``, then we ask for the current value, which is zero because we haven't incremented it yet. Increment the value a couple of times and ask for the current value which is now two! Yay.

### Touch Up

Of course there are some things missing from this example, although creating a module to only hold a counter variable is slightly excessive (but not always!). Our counter process has no way to handle a malformed message, lets fix that.

{% highlight cl %}
(defun counter-loop (count)
  (receive
    ((tuple 'incr)
     (counter-loop (+ count 1)))
    ((tuple 'count requestor)
     (! requestor (tuple 'count count))
     (counter-loop count))
    (msg
     (: io format '"Unknown message received ~p~n", msg)
     (counter-loop count))))
{% endhighlight %}

We simply extend our receive patterns to include a wildcard that responds with the appropriate message, and call the ``counter-loop`` again so we can contiue waiting for other requests.. See how easy that was, now you have no excuses for not handling unknown messages! Although you will most likely want to do something more clever than simply printing a message and happily trunding along, but you get the idea.

That will probably do for now, feel free to give your counter another whirl in the shell to make sure everything still works, but the end result should look something similar to this:

## 4 Thinking About Lisp

### Help from Closures

Now the example we've created is nearly a one for one replication of the original Erlang version from the blog post. How about we starting playing with some more 'Lispy' functionality to see if we can't spice things up a bit. Disclaimer: These may not necessarily be improvements, more to demonstrate that simply writing Erlang code in Lisp isn't enough, there is so much more than can be done!

In our original version we spawn the process and return the ``pid`` in the usual manner, this is all well and good but then every time the user wants to increment the counter they have to make sure the ``pid`` is available and then call one of our functions and pass the ``pid``back in.

### Some Refactoring

Is there an easier way to manage that? Funny you should ask!

{% highlight cl %}
(defun incrementer (pid)
  (lambda ()
    (! (tuple 'incr))))

(defun new ()
  (let ((pid (spawn 'counter 'counter '())))
    (tuple (incrementer pid)))))
{% endhighlight %}

Here we've created an ``incrementer`` function that returns a _button_ of sorts that the user can just hit and it will increment the counter process. We've also adjusted the ``new`` function so that we return that instead of the ``pid``. We can use it like so:

{% highlight cl %}
> (c '"counter.lfe")
#(module counter)
> (set (tuple pid foo) (: counter incrementer))
#(<0.45.0> #Fun<counter.0.27204963>)
> (funcall foo)
#(incr)
> (funcall foo)
#(incr)
> (: counter count pid)
2
{% endhighlight %}

Isn't that nice? We can just hit the button and be confident that the correct counter is being updated.

### More Refactoring

But what can we do about still needing the ``pid`` to ask for the count? We can use a similar solution:

{% highlight cl %}
(defun count-requestor (pid)
  (lambda ()
    (tuple (: counter count pid)
           (count-requestor pid))))
{% endhighlight %}

This time, because we want the actual incremented value we have to return two things, the current value of the counter, and another copy of the ``count-requestor`` function.

Now when we call this function we'll receive a tuple which has value of the counter, and copy of the function so it can be called again later. With just a little adjustment to our ``new`` function we don't have to worry about keeping track of ``pid``s:

{% highlight cl %}
(defun new ()
  (let ((pid (spawn 'counter 'counter '())))
    (tuple (incrementer pid)
           (count-requestor pid)))))
{% endhighlight %}

We can then use it in the shell like so:

{% highlight cl %}
> (c '"counter.lfe")
#(module counter)
> (set (tuple i c) (: counter new))
#(#Fun<counter.0.3300826> #Fun<counter.1.3300826>)
> (funcall i)
#(incr)
> (funcall i)
#(incr)
> (set (tuple result new-c) (funcall c))
#(2 #Fun<counter.1.3300826>)
> result
2
> new-c
#Fun<counter.1.3300826>
{% endhighlight %}

### The Completed Module

So now our final version should look something like this:

{% highlight cl %}
(defmodule counter
  (export (new 0)
          (count 1)
          (counter 0)))

(defun new ()
  "For creating a new counter."
  (let ((pid (spawn 'counter 'counter '())))
    (tuple (incrementer pid)
           (count-requestor pid)))))

(defun incrementer (pid)
  "Increments our counter value."
  (lambda ()
    (! pid (tuple 'incr))))

(defun count-requestor (pid)
  (lambda ()
    (tuple (: counter count pid)
           (count-requestor pid))))

(defun count (counter)
  (! counter (tuple 'count (self)))
  (receive
    ((tuple 'count count)
     count)))

(defun counter ()
  "Retrieves the value of the given counter."
  (counter-loop 0))

(defun counter-loop (count)
  (receive
    ((tuple 'incr)
     (counter-loop (+ count 1)))
    ((tuple 'count requestor)
     (! requestor (tuple 'count count))
     (counter-loop count))
    (msg
     (: io format '"Unknown message received ~p~n" (list msg))
     (counter-loop count))))
{% endhighlight %}

Check out some of our other tutorials and the documentation for more awesome ideas on how Lisp can really some spice to your Erlang.
