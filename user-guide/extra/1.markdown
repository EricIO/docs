---
layout: user-guide
guide: 1
total_guides: 3
---
# 8 Additional Topics

## 8.1 Recursion

In functional languages, recursion plays an important role. For Erlang in
particular, recursion is important because variables can't be changed and
therefor is often very useful take advantage of recursion (examples are given
below).

However, recursion is interesting in and of itself. The roots of functional
programming languages such as Lisp, ML, Erlang, Haskell and others, can
be traced to the concept of recursion in general and the lambda calculus in
particular. Dedekind and Peano seem to be the first to have employed recursion.
Furthermore, Peano gave Bertrand Russell a copy of his "Formulario" which
impacted Russell hugely and quite possibly influenced his efforts on "Principia
Mathematica" which he coauthored several years later. It was from the Principia
that Alonzo Church derived his lambda notation. Church's student John McCarthy
was the creator of Lisp, and used both the lambda and the concept of recursion
in his new language (and, along with Dijkstra, advocated for the inclusions of
recursion in ALGOL).

In this section of the user guide, we explore various aspects of recursion as
they can be formulated in LFE.

### 8.1.1 See Section 8.1

Sorry, couldn't resist.

### 8.1.2 A Mathematical Side Trip

For those that are math-averse, don't let this frighten you -- this will be a
quick and peaceful side-trip that will not leave you bewildered. Rather, it
should provide some nice background for how recursion came to be used. With the
history reviewed, we'll jump into practical implementations.

#### 8.1.2.1 The Dedekind-Peano Axioms

Despite the fluorescence of maths in the 17th and 18th centuries and the
growing impact of number theory, the ground upon which mathematics were built
was shaky at best. Indeed, what we now consider to be the foundations of
mathematics had not even been agreed upon (and this didn't happen until the
first half of the 20th century with the maturation of logic and rise of
axiomatic set theory).

One of the big problems facing mathematicians and one that also prevented the
clarification of the foundations, was understanding integers and operations on
them (e.g., addition, multiplication, etc.). There was a lot of hand-waving
that occurred as well as some clever and mostly-correct analysis.

Richard Dedekind attempted to address this with his method of cuts, however it
was Guiseppe Peano that supplied us with the clearest, most easily described
axioms defining the natural numbers and arithmetic. These can be easily found
in text books and on the Internet; we will take a slightly unique approach,
however, and cast them in Lisp Flavored Erlang.


##### 8.1.2.1.1 A Constant and Equality

The first five Peano axioms deal with the constant (often written as "0") and
the reflexive, symmetric, transitive and closed eqaulity relations. These don't
relate recursion directly, so we're going to skip them ;-)

##### 8.1.2.1.2 Successor Function

The concept of the "successor" in the Peano axioms is a primitive; it is taken
as being true without having proved it. It is informally defined as being the
next number following a given number "n".

In LFE:
{% highlight cl %}
(defun successor (n)
  (+ n 1))
{% endhighlight %}

The things to keep in mind here is that 1) we haven't defined addition yet, and
2) you must not interpred "+" as addition in this context, rather as the
operator that allows for succession to occur. In the world of the Peano axioms,
"+" is only validly used with "n" and "1".

This function is defined as being "basic primitive recursive" (defined by
axioms; the term was coined by Rózsa Péter).

##### 8.1.2.1.3 The Remaining Axioms

The remaining three Peano axioms do not touch upon recursion directly, so we
leave them to your own research and reading pleasure.

#### 8.1.2.2 Primitive Recursive Functions

In addition to the successor function, the other basic privimtive recursive
functions defined are the "zero function", the "projection function" and the
"identity function". These combined with the Peano axioms allow us to define
other primitive functions.

##### 8.1.2.2.1 Addition

Often, one sees the primitive function definition of addition done in the
following manner:

    add(0, x) = x
    add(n + 1, x) = add(n, x) + 1

or:

    add(0, x) = x
    add(s(n), x) = s(add(n, x))

In LFE, we'd like to maintain symmetry with this... however, patterns don't
accept function calls (e.g., to ```(successor n)```). As such, we do a little
juggling instead:
{% highlight cl %}
(defun predecessor
  ((0) 0)
  ((n) (- n 1)))
{% endhighlight %}

Now, we can recast the canonical form above using the workaround of the
```predecessor``` primitive recursive function:
{% highlight cl %}
(defun add
  ((0 x) x)
  ((n x) (+ (add (predecessor n) x) 1)))
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}


##### 8.1.2.1.3

##### 8.1.2.1.4

#### 8.1.2.3 The Ackermann Function

### 8.1.3 Practical Examples in Computing

#### 8.1.3.1 A Simple Example

#### 8.1.3.2 With an Accumulator

#### 8.1.3.3 With Return Values

#### 8.1.3.4 With Lists

### 8.1.4 Tail Calls in LFE

#### 8.1.4.1 Tail Call Optimization
