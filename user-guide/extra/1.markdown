---
layout: user-guide
guide: 1
total_guides: 3
---
# 8 Additional Topics

## 8.1 Recursion

In functional languages, recursion plays an important role. For Erlang in
particular, recursion is important because variables can't be changed and
therefor is often very useful take advantage of recursion to work with changing
values (examples are given below).

However, recursion is interesting in and of itself. The roots of functional
programming languages such as Lisp, ML, Erlang, Haskell and others, can
be traced to the concept of recursion in general and the lambda calculus in
particular.

The Italian mathematician Giuseppe Peano seems to have been one of the first to
have made prominent use of recursion when defining his axioms for defining the
natural numbers. Furthermore, Peano gave Bertrand Russell a copy of his
"Formulario". This impacted Russell hugely and quite possibly influenced his
efforts on "Principia Mathematica" which he coauthored several years later. It
was from the Principia that Alonzo Church derived his lambda notation. Church's
student John McCarthy was the creator of Lisp, and used both the lambda
notation and the concept of recursion in his new language. (Interestingly
enough, McCarthy and Dijkstra both advocated for the inclusions of recursion in
ALGOL.)

In this section of the user guide, we explore various aspects of recursion as
they can be formulated in Lisp Flavored Erlang.

### 8.1.1 See Section 8.1

Sorry, couldn't resist.

### 8.1.2 A Mathematical Side Trip

For those that are math-averse, don't let this frighten you -- this will be a
quick and peaceful journey that will not leave you bewildered. Rather, it
should provide some nice background for how recursion came to be used. With the
history reviewed, we'll make our way into practical implementations.

#### 8.1.2.1 The Dedekind-Peano Axioms

Despite the fluorescence of maths in the 17th and 18th centuries and the
growing impact of number theory, the ground upon which mathematics were built
was shaky at best. Indeed, what we now consider to be the foundations of
mathematics had not even been agreed upon (and this didn't happen until the
first half of the 20th century with the maturation of logic and rise of
axiomatic set theory).

One of the big problems facing mathematicians and one that also prevented the
clarification of the foundations, was this: a thorough, precise, and consistent
definition of the natural numbers as well as operations that could be performed
on them (e.g., addition, multiplication, etc.). There was a long-accepted
intuitive understanding, however, this was insufficient for complete
mathematical rigor.

Richard Dedekind addressed this with his method of cuts, but it was Giuseppe
Peano that supplied us with the clearest, most easily described axioms defining
the natural numbers and arithmetic. These can be easily found in text books and
on the Internet; we will take a slightly unique approach, however, and cast
them in LFE.


##### 8.1.2.1.1 A Constant and Equality

The first five Peano axioms deal with the constant (often written as "0") and
the reflexive, symmetric, transitive and closed eqaulity relations. These don't
relate recursion directly, so we're going to skip them ;-)

##### 8.1.2.1.2 Successor Function

The concept of the "successor" in the Peano axioms is a primitive; it is taken
as being true without having proved it. It is informally defined as being the
next number following a given number "n".

In LFE:
{% highlight cl %}
(defun successor (n)
  (+ n 1))
{% endhighlight %}

The things to keep in mind here are that 1) we haven't defined addition yet,
and 2) you must not interpred "+" as addition in this context, rather as the
operator that allows for succession to occur. In the world of the Peano axioms,
"+" is only validly used with "n" and "1".

This function is defined as being "basic primitive recursive". The basic
primitive recursives are defined by axioms; the term was coined by Rózsa
Péter.

##### 8.1.2.1.3 The Remaining Axioms

The remaining three Peano axioms do not touch upon recursion directly, so we
leave them to your own research and reading pleasure.

#### 8.1.2.2 Primitive Recursive Functions

In addition to the successor function, the other basic privimtive recursive
functions defined are the "zero function", the "projection function" and the
"identity function". These combined with the Peano axioms allow us to define
other primitive functions.

##### 8.1.2.2.1 Addition

Often, one sees the primitive function definition of addition done in the
following manner:

    add(0, x) = x
    add(n + 1, x) = add(n, x) + 1

or:

    add(0, x) = x
    add(succ(n), x) = succ(add(n, x))

In LFE, we'd like to maintain symmetry with this... however, patterns don't
accept function calls (e.g., to ```(successor n)```). As such, we do a little
juggling instead:
{% highlight cl %}
(defun predecessor
  ((0) 0)
  ((n) (- n 1)))
{% endhighlight %}

Now, we can recast the canonical form above using the workaround of the
```predecessor``` primitive recursive function:
{% highlight cl %}
(defun add
  ((0 x) x)
  ((n x) (successor (add (predecessor n) x))))
{% endhighlight %}

All of this may seem rather absurb, given what we do in every-day programming.
Remember, thought: the verbosity of these axioms and derrivatives serves to
explicitly show that no assumptions are being made and that all these
operations can indeed be built upon basic principles.

##### 8.1.2.2.2 Subtraction

Next up, let's take a look at subtraction:

    sub(0, x) = x
    sub(pred(n), x) = pred(sub(n, x))

Similar to addition above, we make some adjustments for the convenience of
pattern matching:
{% highlight cl %}
(defun subtract
  ((0 x) x)
  ((n x) (predecessor (subtract (predecessor n) x))))
{% endhighlight %}

Note that the usual usage is reversed for our ```subtract``` function:
{% highlight cl %}
> (slurp '"prf.lfe")
#(ok prf)
> (subtract 1 100)
99
>
{% endhighlight %}

##### 8.1.2.2.3 Multiplication

The last one of these that we will look at is multiplication, and then we'll
move on to something a little more complicated :-)

    mult(0, x) = 0
    mult(succ(n), x) = x + (x * n)

Again, using our pattern workaround:
{% highlight cl %}
(defun multiply
  ((0 x) 0)
  ((n x) (add x (multiply x (predecessor n)))))
{% endhighlight %}

#### 8.1.2.3 The Ackermann Function

The Ackermann function is one of the simplest and earliest-discovered examples
of a "total computable function" that is not primitive recursive. The variant
of the function that we present below is the two-variable version developed by
Rózsa Péter and Raphael Robinson (the original was more verbose and with three
variables).

Here is the function in LFE
{% highlight cl %}
(defun ackermann
  ((0 n) (+ n 1))
  ((m 0) (ackermann (- m 1) 1))
  ((m n) (ackermann (- m 1) (ackermann m (- n 1)))))
{% endhighlight %}

Here's some example usage:
{% highlight cl %}
> (c '"prf")
#(module prf)
> (: prf ackermann 0 0)
1
> (: prf ackermann 0 1)
2
> (: prf ackermann 1 0)
2
> (: prf ackermann 1 1)
3
> (: prf ackermann 1 2)
4
> (: prf ackermann 2 2)
7
> (: prf ackermann 2 4)
11
> (: prf ackermann 4 1)
65533
>
{% endhighlight %}

#### 8.1.2.4 The Lambda Calculus

Oh, yeah. We just went there.

Take heart, though... this is going to be fun. And after this bit, we'll
finally get to the practical coding bits :-)

Keep in mind that the Peano axioms made use of recursion, that Giuseppe Peano
played a key role in Bertrand Russell's development of the Principia, that
Alonzo Church sought to make improvements on the Principia, and the lambda
calculus eventually arose from these efforts.

Church realized when creating the lambda calculus that with only a lambda at
his disposal, he could define numbers and perform arithmetic upon them. This is
known as "Church encoding". Using what we have defined above, we should be able
to peer into this forest of lambdas and perhaps perceive some trees.

Let's get our feet wet with figuring out how we can define the natural numbers
under Church encoding.

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

##### 8.1.2.3.1

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

##### 8.1.2.3.2

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

##### 8.1.2.3.3

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

##### 8.1.2.3.4

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

### 8.1.3 Practical Examples in Computing

#### 8.1.3.1 A Simple Example

#### 8.1.3.2 With an Accumulator

#### 8.1.3.3 With Return Values

#### 8.1.3.4 With Lists

### 8.1.4 Tail Calls in LFE

#### 8.1.4.1 Tail Call Optimization
