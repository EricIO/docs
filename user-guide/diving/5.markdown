---
layout: user-guide
guide: 5
total_guides: 5
---
#  2 Diving In

## 2.5 Pattern Matching

### 2.5.1 What Are Patterns?

Pattern matching in Erlang is huge, and it has a proportional impact on LFE and
what one can do with this dialect of Lisp. Pattern matching in LFE can be used
in function clauses, ```let```, ```case```, ```receive``` and in the macros
```cond```, ```lc```, and ```bc```.

Pattern matching in LFE happens when an expression matches a given pattern,
e.g.:

    (... (<pattern> <expression>) ...)

where the ```<pattern>``` might be something like this:

{% highlight cl %}
(binary (f float (size 32))
        (b bitstring))
{% endhighlight %}

or this:
{% highlight cl %}
(tuple 'ok value)
{% endhighlight %}

or this:
{% highlight cl %}
(list a b c)
{% endhighlight %}

or this:
{% highlight cl %}
(cons h t)
{% endhighlight %}

and the ```<expression>``` is any legal LFE expression. Ideally, it will return
data that will be matched by the pattern.

If the matching succeeds, any unbound variables in the pattern become bound. If
the matching fails, a run-time error occurs.  All of this is best understood
through the examples given below. Each example is preceeded by the general form
of pattern as used in the given context. This should help keep things clear,
even when the examples get convoluted.

### 2.5.2 Patterns in Forms

#### 2.5.2.1 ```let```

Pattern matching in ```let``` has the following general form:
{% highlight cl %}
(let ((<pattern> <expression>)
      (<pattern> <expression>) ... )
  ... )
{% endhighlight %}

Examples:

{% highlight cl %}
> (let (((tuple len status data) #(8 ok "Trillian")))
       (list len status data))
(8 ok "Trillian")
>
{% endhighlight %}

In this example, we have a pattern of ```(tuple len status data)``` and this is
getting matched against our expression which is some data of the form
```#(8 ok "Trillian")```. The pattern expects a tuple, and a tuple is what we
gave it. With the pattern's variables bound inside the ```let```, we can return
a list of the variables.

If our pattern was written to expect a list and the expression was a tuple,
we'd get a ```badmatch``` error:
{% highlight cl %}
> (let (((list len status data) #(8 ok "Trillian")))
       (list len status data))
exception error: #(badmatch #(8 ok "Trillian"))

>
{% endhighlight %}

Whatever our expression is going to be needs to be matched in the pattern. If
we had a list integers in the expression, we would need a pattern like
```(list i1 i2 i3 ...)```.

Here's a super-simplified version of a ```let``` with pattern matching:
{% highlight cl %}
> (let ((data '"Trillian"))
       (list data))
("Trillian")
>
{% endhighlight %}

Here our pattern was simply the variable ```data``` and our expression was the
string "Trillian". This, of course, is easily recognized as a standard variable
assignment within a ```let```.

Patterns can nest, though, and with this you can start to get a sense of the
power they hold. Let's look at a more complicated example:
{% highlight cl %}
> (let (((tuple lens status data)
         #((8 43) #(err "msg too short") "Trillian")))
       (list lens status data))
("\b+" #(err "msg too short") "Trillian")
>
{% endhighlight %}

As you can see, we've nested our expression: length is a two-valued list and
status is a two-valued tuple. Our pattern, however, is still simple. But this
is going to change: we want to extract our data into more variables, and we do
this by mirroring the expression data structure in the pattern itself:
{% highlight cl %}
> (let (((tuple (list len-data len-total) (tuple status-code status-msg) data)
         #((8 43) #(err "msg too short") "Trillian")))
       (list len-data len-total status-code status-msg data))
(8 43 err "msg too short" "Trillian")
>
{% endhighlight %}

As you can see, our nested pattern extracted the data into the pattern's
variables. If all we cared about was the status message, we could make
this simpler by using the "I don't care" variable (the underscore):
{% highlight cl %}
> (let (((tuple (list _ _) (tuple _ status-msg) _)
         #((8 43) #(err "msg too short") "Trillian")))
       (list status-msg))
("msg too short")
{% endhighlight %}

#### 2.5.2.2 ```case```

Pattern matching in ```case``` has the following general form:
{% highlight cl %}
(case <expression>
  (<pattern> <expression> ... )
  (<pattern> <expression> ... )
  ...)
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

#### 2.5.2.3 ```receive```

Pattern matching in ```receive``` has the following general form:
{% highlight cl %}
(receive
  (<pattern> ... )
  (<pattern> ... )
  ...
  (after timeout
    ... ))
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

#### 2.5.2.4 ```cond```

Pattern matching in ```cond``` has the following general form:
{% highlight cl %}
(cond (<test> ... )
      ((?= <pattern> <expr>) ... )
      ... )
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

### 2.5.3 Special Cases

#### 2.5.3.1 Arguments to ```defun```

Pattern matching in functions has the following general form:
{% highlight cl %}
    (defun name
      ((argpat ...) ...)
      ...)
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

#### 2.5.3.2 Aliases with ```=```

Aliases are defined with the following general form:
{% highlight cl %}
( ... (= <pattern 1> <pattern 2>) ... )
{% endhighlight %}

Aliases can be used anywhere in a pattern.

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

#### 2.5.3.3 Patterns in Comprehensions

List and binary comprehensions make use of patterns in a limited sense. They
have the following general forms:
{% highlight cl %}
 (<- pat guard list-expr)
{% endhighlight %}
and
{% highlight cl %}
(<= bin-pat guard binary-expr)
{% endhighlight %}
where the ```guard``` in both cases is optional.

You can read more about LFE comprehensions in
<a href="/user-guide/data/2.html">section 3.2</a>
{% highlight cl %}
{% endhighlight %}

{% highlight cl %}
{% endhighlight %}

